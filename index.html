<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Fast 2D Vector Explorer (LOD)</title>
<style>
    html, body {
        margin: 0; padding: 0;
        overflow: hidden;
        background: #0a0a0f;
        font-family: sans-serif;
        color: white;
    }
    #overlay {
        position: fixed;
        top: 10px; left: 10px;
        background: rgba(0,0,0,0.5);
        padding: 6px 10px;
        border-radius: 4px;
        font-size: 14px;
        pointer-events: none;
        color: #ddd;
    }
</style>
</head>
<body>

<canvas id="c"></canvas>
<div id="overlay">loading…</div>

<script>
////////////////////////////////////////////////////////////////
// globals
////////////////////////////////////////////////////////////////
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
const overlay = document.getElementById("overlay");
let DPR = window.devicePixelRatio || 1;

let W = 0, H = 0;
let zoom = 300;
let cx = 0;
let cy = 0;

let pts = [];
let hoverIdx = -1;
let pinnedIdx = -1;

let isPanning = false;
let panStart = [0, 0];
let cx0, cy0;

// spatial hash for fast picking
let grid = {};
let gridSize = 0.15; // world units per cell

////////////////////////////////////////////////////////////////
// resize
////////////////////////////////////////////////////////////////
function resize() {
    W = window.innerWidth;
    H = window.innerHeight;

    canvas.width = W * DPR;
    canvas.height = H * DPR;
    canvas.style.width = W + "px";
    canvas.style.height = H + "px";

    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    draw();
}

window.addEventListener("resize", resize);

////////////////////////////////////////////////////////////////
// coordinate transforms
////////////////////////////////////////////////////////////////
function clientToCanvas(x, y) {
    const r = canvas.getBoundingClientRect();
    return [
        (x - r.left) * DPR,
        (y - r.top) * DPR
    ];
}

function screenToWorld(sx, sy) {
    return [
        cx + (sx / DPR - W/2) / zoom,
        cy + (sy / DPR - H/2) / zoom
    ];
}

function worldToScreen(x, y) {
    return [
        (x - cx) * zoom + W/2,
        (y - cy) * zoom + H/2
    ];
}

////////////////////////////////////////////////////////////////
// LOD: decide how many points to skip
////////////////////////////////////////////////////////////////
function lodStep() {
    if (zoom > 900) return 1;   // very zoomed in
    if (zoom > 600) return 2;
    if (zoom > 350) return 3;
    if (zoom > 200) return 4;
    if (zoom > 120) return 6;
    if (zoom > 80)  return 10;
    return 18; // zoomed out like hell — skip more
}

////////////////////////////////////////////////////////////////
// spatial hash
////////////////////////////////////////////////////////////////
function buildSpatialIndex() {
    grid = {};
    for (let i = 0; i < pts.length; i++) {
        const p = pts[i];
        const gx = Math.floor(p.x / gridSize);
        const gy = Math.floor(p.y / gridSize);
        const key = gx + "," + gy;
        if (!grid[key]) grid[key] = [];
        grid[key].push(i);
    }
}

function pickNearest(worldX, worldY, rWorld) {
    const gx = Math.floor(worldX / gridSize);
    const gy = Math.floor(worldY / gridSize);

    let best = -1;
    let bestDist = rWorld * rWorld;

    for (let dx=-1; dx<=1; dx++) {
        for (let dy=-1; dy<=1; dy++) {
            const bucket = grid[(gx+dx)+","+(gy+dy)];
            if (!bucket) continue;

            for (const idx of bucket) {
                const p = pts[idx];
                const dxw = p.x - worldX;
                const dyw = p.y - worldY;
                const d2 = dxw*dxw + dyw*dyw;
                if (d2 < bestDist) {
                    bestDist = d2;
                    best = idx;
                }
            }
        }
    }
    return best;
}

////////////////////////////////////////////////////////////////
// mouse events
////////////////////////////////////////////////////////////////
window.addEventListener("mousemove", (e) => {
    const [sx, sy] = clientToCanvas(e.clientX, e.clientY);

    if (isPanning) {
        const dx = (e.clientX - panStart[0]) / zoom;
        const dy = (e.clientY - panStart[1]) / zoom;
        cx = cx0 - dx;
        cy = cy0 - dy;
        draw();
    } else {
        const [wx, wy] = screenToWorld(sx, sy);
        hoverIdx = pickNearest(wx, wy, 0.04);
        draw();
    }
});

canvas.addEventListener("mousedown", (e) => {
    isPanning = true;
    panStart = [e.clientX, e.clientY];
    cx0 = cx;
    cy0 = cy;
});

window.addEventListener("mouseup", () => {
    isPanning = false;
});

canvas.addEventListener("click", (e) => {
    const [sx, sy] = clientToCanvas(e.clientX, e.clientY);
    const [wx, wy] = screenToWorld(sx, sy);
    const idx = pickNearest(wx, wy, 0.04);
    if (idx !== -1) pinnedIdx = idx;
    draw();
});

canvas.addEventListener("wheel", (e) => {
    e.preventDefault();
    const [sx, sy] = clientToCanvas(e.clientX, e.clientY);
    const [wx, wy] = screenToWorld(sx, sy);

    const factor = Math.pow(1.15, -Math.sign(e.deltaY));
    zoom = Math.max(50, Math.min(6000, zoom * factor));

    cx = wx - (sx / DPR - W/2) / zoom;
    cy = wy - (sy / DPR - H/2) / zoom;

    draw();
}, { passive:false });

////////////////////////////////////////////////////////////////
// drawing
////////////////////////////////////////////////////////////////
function draw() {
    ctx.fillStyle = "#0a0a0f";
    ctx.fillRect(0, 0, W, H);

    const step = lodStep();

    // batch rendering by skipping points
    ctx.lineWidth = 1;

    for (let i=0; i<pts.length; i+=step) {
        const p = pts[i];
        const [sx, sy] = worldToScreen(p.x, p.y);

        ctx.fillStyle = `rgb(${p.r*255}, ${p.g*255}, ${p.b*255})`;
        const size = (i===hoverIdx || i===pinnedIdx) ? 6 : 3;

        ctx.beginPath();
        ctx.arc(sx, sy, size, 0, Math.PI*2);
        ctx.fill();
    }

    // hover label
    if (hoverIdx !== -1) {
        const p = pts[hoverIdx];
        const [sx, sy] = worldToScreen(p.x, p.y);
        ctx.fillStyle = "white";
        ctx.fillText(p.label, sx + 10, sy - 10);
    }

    // pinned label
    if (pinnedIdx !== -1) {
        const p = pts[pinnedIdx];
        const [sx, sy] = worldToScreen(p.x, p.y);
        ctx.fillStyle = "rgb(255,200,100)";
        ctx.fillText(p.label, sx + 10, sy + 4);
    }
}

////////////////////////////////////////////////////////////////
// load vector data
////////////////////////////////////////////////////////////////
async function loadData() {
    let res = await fetch("vectors.json");
    let data = await res.json();
    pts = data.points;

    overlay.textContent = `loaded ${pts.length} points`;
    buildSpatialIndex();
    draw();
}

resize();
loadData();
</script>
</body>
</html>
