<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>2D Semantic Explorer</title>
<style>
    body {
        margin: 0;
        overflow: hidden;
        background: #0a0a0f;
        font-family: sans-serif;
        color: white;
    }
    #info {
        position: fixed;
        top: 10px;
        left: 10px;
        background: rgba(0,0,0,0.5);
        padding: 6px 10px;
        border-radius: 6px;
        font-size: 14px;
        pointer-events: none;
        max-width: 380px;
        white-space: pre-wrap;
    }
</style>
</head>
<body>

<canvas id="c"></canvas>
<div id="info">loadingâ€¦</div>

<script src="https://cdn.jsdelivr.net/npm/regl/dist/regl.min.js"></script>

<script>
const canvas = document.getElementById("c");
const info = document.getElementById("info");

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// --------------------------------------
// load vectors.json
// --------------------------------------
fetch("vectors.json")
    .then(r => r.json())
    .then(run);

function run(data) {
    info.textContent = "loaded " + data.points.length + " points";

    const pts = data.points;

    const positions = pts.map(p => [p.x, p.y]);
    const colors = pts.map(p => [p.r, p.g, p.b]);
    const labels = pts.map(p => p.label);

    // pan & zoom
    let zoom = 1.0;
    let offset = [0, 0];

    canvas.onwheel = e => {
        const z = Math.exp(-e.deltaY * 0.001);
        zoom *= z;
    };

    let dragging = false;
    let lx = 0, ly = 0;

    canvas.onmousedown = e => {
        dragging = true;
        lx = e.clientX;
        ly = e.clientY;
    };
    canvas.onmouseup = () => dragging = false;
    canvas.onmouseleave = () => dragging = false;
    canvas.onmousemove = e => {
        if (dragging) {
            offset[0] += (e.clientX - lx) / zoom;
            offset[1] -= (e.clientY - ly) / zoom;
            lx = e.clientX;
            ly = e.clientY;
        }
    };

    // nearest-point hover
    canvas.addEventListener("mousemove", e => {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left - canvas.width/2) / zoom - offset[0];
        const y = -(e.clientY - rect.top - canvas.height/2) / zoom - offset[1];

        let best = -1;
        let bd = 0.03;

        for (let i = 0; i < positions.length; i++) {
            const dx = positions[i][0] - x;
            const dy = positions[i][1] - y;
            const d = dx*dx + dy*dy;
            if (d < bd) {
                bd = d;
                best = i;
            }
        }

        if (best >= 0) {
            info.textContent = labels[best];
        }
    });

    const regl = createREGL({canvas: canvas});

    const draw = regl({
        frag: `
            precision mediump float;
            varying vec3 vcolor;
            void main() {
                float d = length(gl_PointCoord.xy - 0.5);
                if (d > 0.5) discard;
                gl_FragColor = vec4(vcolor, 1.0);
            }
        `,
        vert: `
            precision mediump float;
            attribute vec2 position;
            attribute vec3 color;
            uniform float zoom;
            uniform vec2 offset;
            uniform vec2 viewport;

            varying vec3 vcolor;

            void main() {
                vec2 p = (position + offset) * zoom;
                vec2 clip = 2.0 * p / viewport;
                gl_Position = vec4(clip, 0.0, 1.0);
                gl_PointSize = 6.0;
                vcolor = color;
            }
        `,
        attributes: {
            position: positions,
            color: colors,
        },
        uniforms: {
            zoom: () => zoom,
            offset: () => offset,
            viewport: () => [canvas.width/2, canvas.height/2],
        },
        count: positions.length,
        primitive: 'points',
    });

    regl.frame(() => {
        regl.clear({color: [0.04,0.04,0.08,1], depth: 1});
        draw();
    });
}
</script>

</body>
</html>
